#!/usr/bin/env node
/* eslint-disable linebreak-style */
/**
 * Module dependencies.
 */

var app = require("../app");
var debug = require("debug")("music:server");
var http = require("http");
var socketIO = require("socket.io");

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || "3000");
app.set("port", port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on("error", onError);
server.on("listening", onListening);

var io = socketIO.listen(server);
io.sockets.on("connection", function(socket) {

	// convenience function to log server messages on the client
	function log() {
		var array = ["Message from server:"];
		array.push.apply(array, arguments);
		socket.emit("log", array);
	}

	socket.on("message", function(message) {
		//log("Client said: ", message);
		// for a real app, would be room-only (not broadcast)
		socket.broadcast.emit("message", message);
	});

	socket.on("create or join", function(room) {
		//log("Received request to create or join room " + room);

		var clientsInRoom = io.sockets.adapter.rooms[room];
		var numClients = clientsInRoom ? Object.keys(clientsInRoom.sockets).length : 0;
		//log("Room " + room + " now has " + numClients + " client(s)");

		if (numClients === 0) {
			socket.join(room);
			//log("Client ID " + socket.id + " created room " + room);
			socket.emit("created", room, socket.id);
		} else if (numClients === 1) {
			//log("Client ID " + socket.id + " joined room " + room);
			// io.sockets.in(room).emit('join', room);
			socket.join(room);
			socket.emit("joined", room, socket.id);
			io.sockets.in(room).emit("ready", room);
			socket.broadcast.emit("ready", room);
		} else { // max two clients
			socket.emit("full", room);
		}
	});

	socket.on("ipaddr", function() {
		var ifaces = os.networkInterfaces();
		for (var dev in ifaces) {
			ifaces[dev].forEach(function(details) {
				if (details.family === "IPv4" && details.address !== "127.0.0.1") {
					socket.emit("ipaddr", details.address);
				}
			});
		}
	});

	socket.on("disconnect", function(reason) {
		//console.log(`Peer or server disconnected. Reason: ${reason}.`);
		socket.broadcast.emit("bye");
	});

	socket.on("bye", function(room) {
		//console.log(`Peer said bye on room ${room}.`);
	});
});

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10);

	if (isNaN(port)) {
		// named pipe
		return val;
	}

	if (port >= 0) {
		// port number
		return port;
	}

	return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== "listen") {
		throw error;
	}

	var bind = typeof port === "string"
		? "Pipe " + port
		: "Port " + port;

	// handle specific listen errors with friendly messages
	switch (error.code) {
	case "EACCES":
		console.error(bind + " requires elevated privileges");
		process.exit(1);
		break;
	case "EADDRINUSE":
		console.error(bind + " is already in use");
		process.exit(1);
		break;
	default:
		throw error;
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
	var addr = server.address();
	var bind = typeof addr === "string"
		? "pipe " + addr
		: "port " + addr.port;
	debug("Listening on " + bind);
}
